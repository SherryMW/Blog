---
category: IT
article: false
order: 7
---

# 原码反码补码

## byte 与 bit

- byte（字节）是计算机存储和处理数据的基本单位，通常由 8 个比特（bit）组成。每个比特（bit）是计算机中最小的存储单位，只能存储 0 或者 1 这两个状态。因此，一个字节（byte）可以存储 8 个比特（bit）的数据

- 两者之间的关系是：1 byte = 8 bit，既 8 个比特（bit）组成一个字节（byte）

- 在计算机中，数据通常以字节（byte）为单位进行存储和传输（字节是最小的存储和传输单位），而比特（bit）则是用来表示数据的最小单位

- 1 byte = 8 bit

- 1 KB = 1024 byte

- 1 MB = 1024 KB

- 1 GB = 1024 MB

- 1 TB = 1024 GB

## 原码反码补码

- 原码反码补码是计算机二进制的三种表示形式

- 计算机在底层都是采用二进制补码的形式来表示

- 二进制位最高位称为符号位，0 为正数，1 为负数

## 正数的原码反码补码

- 正数的原码反码补码是相同的

- 127 的原码反码补码都是 0111 1111

## 负数的原码反码补码

- 负数的原码运算规则：将绝对值转换为二进制后，最高位改为 1

- -5 的原码：1000 0101

- -5 的反码：1111 1010（以原码作为参考，符号位不变，其他位取反）

- -5 的补码：1111 1011（以反码作为参考，符号位不变，然后加 1）

## 已知负数补码怎么得到原码

如果已知补码，求原码：补码符号位不变，其余位取反，再加 1 即可。例如 -5 的补码 1111 1011 符号位不变，其余位取反 1000 0100 最后加 1 的结果为 1000 0101

-128 的原码反码补码：

- -128 原码：将绝对值转换为二进制后，最高位改为 1。绝对值转换为二进制后，结果为 1000 0000，因此最高位已经是 1 了，因此结果就是 1000 0000

- -128 反码：以原码作为参考，符号位不变，其他位取反。结果为：1111 1111

- -128 补码：以反码作为参考，符号位不变，然后加 1。结果为：1000 0000（-128 的原码和补码是一样的）

1 byte = 8bit 一个字节，8个二进制码取值范围为 1000 0000 ~ 0111 1111 相当于 -128 ~ 127

根据这个取值范围可以表示 256 种不同的状态，负的 128 个，正的 127 个，以及加上中间的 0，也就是说一个字节可以表示 256 种不同的二进制码

## 计算机底层为什么采用补码

计算机底层采用补码进行数值表示和运算，主要是因为它在硬件实现和运算逻辑上具有诸多优点：

- 统一的加减法运算：补码使得加法和减法运算可以使用同一个电路实现。具体来说，减法运算可以转换为加法运算，这样可以简化 ALU（算术逻辑单元）的设计。例如，a - b 可以表示为 a + (-b)，其中 -b 是 b 的补码

- 符号位的一致性：补码表示的数值中，最高位（符号位）的权重与其它位一致，这样有利于处理符号扩展问题。例如，将一个 8 位的补码数扩展为 16 位时，只需要对符号位进行复制即可，不会改变数值的实际大小

- 单个零表示：补码表示法只有一个零，即所有位为零时表示数值零。这不同于原码和反码，它们有两个零（+0 和 -0），会带来额外的复杂性

    - 在补码表示法中，零的二进制表示是所有位都为零，00000000 由于补码对负数的处理方式，零的负数表示（即 -0）在补码表示中会转化为正零。-0 的补码：最高位改 1 取反 0000 0000 -> 1111 1111（得到反码）；以反码作为参考，符号位不变，然后加 1 ，结果为 1 0000 0000，由于是 8 位二进制数，最高位被丢弃，结果就是 0000 0000，既正零

如果计算机采用原码的方式进行计算 -3 + 2：

-3 的原码：1000 0011

2 的原码：0000 0010

1000 0011 + 0000 0010 = 1000 0101 = -5

如果计算机采用补码计算：

-3 的补码：1111 1101

2 的补码：0000 0010

1111 1101 + 0000 0010 = 1111 1111（补码）

最后要把补码转成原码，符号位不变，取反加一：1111 1111 -> 1000 0000 -> 1000 0001 = -1